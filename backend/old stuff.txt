#!/usr/bin/env python
import pika
import threading
import os, sys, time

class Airplane(threading.Thread):
    def __init__(self, name, time, state):
        super().__init__()
        self.name = name
        self.time = time
        self.state = state
        
        # Start both the main thread and a separate thread for receiving messages
        self.receive_thread = threading.Thread(target=self.receive, daemon=True)
        self.receive_thread.start()
        
        self.start()  # Runs run() in its own thread

    def run(self):  # This method is called when start() is executed
        message = f"Airplane {self.name} is ready to take off, {self.state}"

        connection = pika.BlockingConnection(
            pika.ConnectionParameters(host='localhost')
        )
        channel = connection.channel()

        channel.queue_declare(queue='flight_telemetry')

        channel.basic_publish(exchange='', routing_key='flight_telemetry', body=message)
        print("Sent:", message)

        time.sleep(self.time)

        message = f"Airplane {self.name} has taken off, {self.state}"
        channel.basic_publish(exchange='', routing_key='flight_telemetry', body=message)
        print("Sent:", message)

        connection.close()

    def receive(self):
        """ Continuously listen for messages from ATC. """
        connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
        channel = connection.channel()

        channel.queue_declare(queue='commands')

        def callback(ch, method, properties, body):
            print(f"Received from ATC: {body}")  # Decode the bytes message
        
        channel.basic_consume(queue='commands', on_message_callback=callback, auto_ack=True)

        print(f"[{self.name}] Waiting for messages. To exit press CTRL+C")
        channel.start_consuming()  # Keeps running in an infinite loop

if __name__ == '__main__':
    if len(sys.argv) != 4:
        print("Usage: airplane.py <id> <time> <state>")
        sys.exit(1)

    plane_id = int(sys.argv[1])
    plane_time = int(sys.argv[2])
    plane_state = sys.argv[3]  # Use as a string (avoid int conversion)

    try:
        plane = Airplane(plane_id, plane_time, plane_state)
        plane.join()  # Wait for the main thread (run method) to finish
    except KeyboardInterrupt:
        print('Interrupted')
        sys.exit(0)



#######



#!/usr/bin/env python
import pika, sys, os


def sending_commands(message):
    connection = pika.BlockingConnection(
    pika.ConnectionParameters(host='localhost'))
    channel = connection.channel()

    channel.queue_declare(queue='commands')
    channel.basic_publish(exchange='', routing_key='commands', body=message)
    print("Sent from ATC: ", message)
    connection.close()

def process_telemetry(body):
    string_data = body.decode('utf-8')
    parts = string_data.split(",")
    message_mess = parts[0]
    plane_state = parts[1]
    print("#######")
    print(plane_state)
    match plane_state.strip():
        case "approaching_n":
            commands = "plane is approaching from North"
            sending_commands(commands)
        case "approaching_s":
            commands = "plane is approaching from South"
            sending_commands(commands)
        case "approaching_e":
            print("not gonna send command back lol")


def receiving_telemetry():
    connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
    channel = connection.channel()

    channel.queue_declare(queue='flight_telemetry')

    def callback(ch, method, properties, body): #method to run when message is received.
        print(f" [x] Received {body}")
        process_telemetry(body)


    channel.basic_consume(queue='flight_telemetry', on_message_callback=callback, auto_ack=True)

    print(' [*] Waiting for messages. To exit press CTRL+C')
    channel.start_consuming()



if __name__ == '__main__':
    try:
        receiving_telemetry()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)